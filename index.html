<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 Game</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: #faf8ef;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            padding: 20px;
        }

        .container {
            width: 500px;
            padding: 15px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 48px;
            font-weight: bold;
            color: #776e65;
        }

        .scores {
            display: flex;
            gap: 10px;
        }

        .score-box {
            background: #bbada0;
            padding: 10px 20px;
            border-radius: 3px;
            color: white;
            min-width: 100px;
            text-align: center;
        }

        .score-label {
            display: block;
            font-size: 13px;
            margin-bottom: 4px;
        }

        #score, #best-score {
            font-size: 20px;
            font-weight: bold;
        }

        #new-game {
            background: #8f7a66;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 3px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        #new-game:hover {
            background: #9f8a76;
        }

        .game-container {
            position: relative;
            background: #bbada0;
            padding: 15px;
            border-radius: 6px;
            width: 470px;
            height: 470px;
        }

        .grid-background, .grid-container {
            position: absolute;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-gap: 15px;
            width: calc(100% - 30px);
            height: calc(100% - 30px);
        }

        .grid-cell {
            background: rgba(238, 228, 218, 0.35);
            border-radius: 3px;
        }

        .tile {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100px;
            height: 100px;
            font-size: 45px;
            font-weight: bold;
            border-radius: 3px;
            transition: transform 0.15s ease, opacity 0.15s ease;
            animation: appear 0.2s ease;
        }

        @keyframes appear {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .tile.merged {
            animation: merge 0.2s ease;
        }

        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        .tile-128 { 
            background: #edcf72; 
            color: #f9f6f2;
            font-size: 40px;
        }
        .tile-256 { 
            background: #edcc61; 
            color: #f9f6f2;
            font-size: 40px;
        }
        .tile-512 { 
            background: #edc850; 
            color: #f9f6f2;
            font-size: 40px;
        }
        .tile-1024 { 
            background: #edc53f; 
            color: #f9f6f2;
            font-size: 35px;
        }
        .tile-2048 { 
            background: #edc22e; 
            color: #f9f6f2;
            font-size: 35px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>2048</h1>
            <div class="scores">
                <div class="score-box">
                    <span class="score-label">SCORE</span>
                    <span id="score">0</span>
                </div>
                <div class="score-box">
                    <span class="score-label">BEST</span>
                    <span id="best-score">0</span>
                </div>
            </div>
            <button id="new-game">New Game</button>
        </div>
        <div class="game-container">
            <div class="grid-background">
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
                <div class="grid-cell"></div>
            </div>
            <div class="grid-container">
                <!-- Tiles will be added here dynamically -->
            </div>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.gridSize = 4;
                this.gridContainer = document.querySelector('.grid-container');
                this.scoreElement = document.getElementById('score');
                this.bestScoreElement = document.getElementById('best-score');
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('bestScore')) || 0;
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
                this.setupNewGame();
                this.setupEventListeners();
            }

            setupNewGame() {
                this.clearGrid();
                this.score = 0;
                this.updateScore();
                this.addRandomTile();
                this.addRandomTile();
            }

            clearGrid() {
                this.gridContainer.innerHTML = '';
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
            }

            updateScore() {
                this.scoreElement.textContent = this.score;
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    this.bestScoreElement.textContent = this.bestScore;
                    localStorage.setItem('bestScore', this.bestScore);
                }
            }

            addRandomTile() {
                const emptyCells = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!this.grid[row][col]) {
                            emptyCells.push({ row, col });
                        }
                    }
                }

                if (emptyCells.length) {
                    const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    const value = Math.random() < 0.9 ? 2 : 4;
                    this.grid[row][col] = value;
                    this.createTile(row, col, value);
                }
            }

            createTile(row, col, value) {
                const tile = document.createElement('div');
                tile.className = `tile tile-${value}`;
                tile.textContent = value;
                tile.style.setProperty('--x', col);
                tile.style.setProperty('--y', row);
                this.positionTile(tile, row, col);
                this.gridContainer.appendChild(tile);
                return tile;
            }

            positionTile(tile, row, col) {
                tile.style.transform = `translate(${col * 115}px, ${row * 115}px)`;
            }

            setupEventListeners() {
                document.addEventListener('keydown', this.handleKeyPress.bind(this));
                document.getElementById('new-game').addEventListener('click', () => this.setupNewGame());
                
                // Touch events for mobile
                let touchStartX, touchStartY;
                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });

                document.addEventListener('touchend', (e) => {
                    if (!touchStartX || !touchStartY) return;

                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;

                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;

                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0) this.move('right');
                        else this.move('left');
                    } else {
                        if (deltaY > 0) this.move('down');
                        else this.move('up');
                    }
                });
            }

            handleKeyPress(event) {
                if (event.key.startsWith('Arrow')) {
                    event.preventDefault();
                    const direction = event.key.replace('Arrow', '').toLowerCase();
                    this.move(direction);
                }
            }

            move(direction) {
                const previousGrid = this.grid.map(row => [...row]);
                let moved = false;
                
                // Determine movement parameters based on direction
                const movements = {
                    'up': { start: 1, end: this.gridSize, step: 1, isRow: true },
                    'down': { start: this.gridSize - 2, end: -1, step: -1, isRow: true },
                    'left': { start: 1, end: this.gridSize, step: 1, isRow: false },
                    'right': { start: this.gridSize - 2, end: -1, step: -1, isRow: false }
                };

                const movement = movements[direction];
                
                // Process movement
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = movement.start; j != movement.end; j += movement.step) {
                        const current = movement.isRow ? [j, i] : [i, j];
                        const next = movement.isRow ? [j - movement.step, i] : [i, j - movement.step];
                        
                        if (this.grid[current[0]][current[1]]) {
                            let [newRow, newCol] = next;
                            let value = this.grid[current[0]][current[1]];
                            
                            while (
                                newRow >= 0 && newRow < this.gridSize &&
                                newCol >= 0 && newCol < this.gridSize
                            ) {
                                if (!this.grid[newRow][newCol]) {
                                    this.grid[newRow][newCol] = value;
                                    this.grid[current[0]][current[1]] = null;
                                    [current[0], current[1]] = [newRow, newCol];
                                    moved = true;
                                } else if (this.grid[newRow][newCol] === value) {
                                    this.grid[newRow][newCol] *= 2;
                                    this.grid[current[0]][current[1]] = null;
                                    this.score += this.grid[newRow][newCol];
                                    moved = true;
                                    break;
                                } else {
                                    break;
                                }
                                
                                newRow = movement.isRow ? newRow - movement.step : newRow;
                                newCol = movement.isRow ? newCol : newCol - movement.step;
                            }
                        }
                    }
                }

                if (moved) {
                    this.updateGrid();
                    this.addRandomTile();
                    this.updateScore();
                    
                    if (this.isGameOver()) {
                        setTimeout(() => alert('Game Over!'), 300);
                    }
                }
            }

            updateGrid() {
                this.gridContainer.innerHTML = '';
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col]) {
                            this.createTile(row, col, this.grid[row][col]);
                        }
                    }
                }
            }

            isGameOver() {
                // Check for empty cells
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!this.grid[row][col]) return false;
                    }
                }

                // Check for possible merges
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const current = this.grid[row][col];
                        // Check right neighbor
                        if (col < this.gridSize - 1 && this.grid[row][col + 1] === current) return false;
                        // Check bottom neighbor
                        if (row < this.gridSize - 1 && this.grid[row + 1][col] === current) return false;
                    }
                }

                return true;
            }
        }

        // Start the game
        new Game();
    </script>
</body>
</html>
